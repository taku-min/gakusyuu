<!-- /*やっと草の生やし方が分かった。今日からしっかりと学習して遅れを取り戻す。/ -->
<!--/* 2ヶ月も掛かってしまった。-->
<!-- /*今日はrubyの１を学習した。/ -->
<!-- /* 基本をやり直す！-->
<!-- /*11月21日はrubyの変数の値を変更するをやった。-->
<!-- /* 11月22日 変数の定義後に、値を変更をした。-->
<!-- /* 11月23日 変数展開について学習した。-->
<!-- /* 11月24日 今日はif文について学習した。-->
ex  if
      puts
    end
<!-- /* 11月25日 今日は条件分岐について学習した。比較演算子で比較した結果を出力させるものです。-->

<!-- /* 11月26日 今日は比較演算子について学習した。-->
ex  
  a==b  trueは等しければtrue、等しくなければfalse

<!-- /* 11月27日 今日は条件分岐のelseについて学習した。-->
ex
  もし〇〇なら●●を行う、そうでなければ■■を行う
  if
   puts...
  else
   puts...
  end

<!-- /* 11月28日 今日は条件分岐のelsifについて学習した。-->
ex
  もし..だったら..を行う、そうでなくもし..であれば..を行う、いずれでもなければ..を行う
  if
   puts...
  elsif 
   puts...
  else
   puts...
  end

<!-- /* 11月29日 今日は条件分岐の『かつ、または』について学習した。-->
ex 
  かつ＝ &&
  または＝ ||

<!-- /* 11月30日 今日は配列について学習した。
配列は、[値1, 値2, 値3]のように作り、配列に入っているそれぞれの値のことを要素と呼びます。-->


<!-- /* 12月1日 今日は配列のインデックス番号について学習した。
配列の要素には、前から順に「0, 1, 2, ...」と数字が割り振られており、これをインデックス番号といいます。-->

<!-- /* 12月2日 今日は配列と繰り返し処理について学習した。
繰り返し処理には、each文を使います。each文は「配列.each do |変数名|」と書き、「end」までの間に実行したい処理を書く。-->

<-- /* 12月3日 今日はeach文の中の変数について学習した。
each文で各要素が1つずつ代入される|変数|は、doからendまでの間でしか使用することはできない。
each文の外で定義した変数は、each文の中でも使うことができる。変数の使用できる範囲のことをスコープと呼ぶ。-->

<-- /*12月4日 今日はハッシュについて学習しました。
ハッシュはそれぞれの値にキーと呼ばれる名前をつけて管理します。
{キー1 => 値1, キー2 => 値2}のように作ります。 -->

<-- /* 12月5日 今日はハッシュ[キー]= 値について学習した。
ex  user["name"]とすると、ハッシュuserのキー「"name"」と対応している値を用いることができます。 -->

<-- /* 12月6日 今日はハッシュのキーの部分を文字列ではなく、先頭にコロン「:」を付けた書き方をするについて学習した。
この「:name」という書き方のことをシンボルと言う。-->

<-- /* 12月7日 今日もハッシュについて学習した。ハッシュのキーにシンボルを用いるときには、省略した書き方をすることができます。
ex
{"name"=>"tanaka","age"=>21}
{:name=>"tanaka",:age=>21}
{name:"tanaka", age:21}  -->

<-- /* 12月8日 今日もハッシュの存在しないキーを指定について学習した。
ハッシュから存在しないキーの値を取り出した時の「何もない」という値は、Rubyでは「nil」(読み方：ニル)という特別な値で表現されます。 -->

<-- /* 12月9日 今日はハッシュの配列について学習した。 
配列の値がハッシュなので、配列[インデックス番号]で対応するハッシュを用いることができる。-->

<-- /* 12月10日 今日もハッシュの配列について学習した。
配列[インデックス番号][キー]で、特定のハッシュの値を用いることができます。-->

<-- /* 12月11日 今日はeachの中でハッシュの値を使うについて学習した。
ex  exams = [
  {subject: "Math", score: 80},
  {subject: "Science", score: 55}
]
exams.each do |exam|
  puts "#{exam[:subject]}の結果は#{exam[:score]}点です"
end  -->

<-- /* 12月12日 今日はrubyのメソッドについて学習した。
メソッドとは、複数の処理を1つにまとめたもので、「def メソッド名」と「end」の間に、まとめたい処理を書くことでメソッドをつくることができます。
このことを「メソッドを定義する」と言います。-->

<-- /* 12月13日 今日はrubyのメソッドを自作してみました。
ex def print_info
  puts "でんきやへようこそ！"
  puts "今日はヘッドホンを買います！"
end

print_info

<-- /* 12月14日 今日はrubyのメソッド引数について学習した。
引数とはメソッドに与える追加情報のようなものです。
メソッドを呼び出すときに一緒に引数を渡すことで、メソッドの中でその値を利用することができます。 -->

<-- /* 12月15日 今日もrubyのメソッド引数の続きを学習した。
def print_info(item)
  puts "でんきやへようこそ！"
  puts "今日は#{item}がセール中です！"
end

# 引数を「ヘッドホン」としてメソッドを呼び出してください
print_info("ヘッドホン")

# 引数を「テレビ」としてメソッドを呼び出してください
print_info("テレビ")

<-- /* 12月16日 今日もrubyのメソッド引数の複数について学習した。
複数の引数を渡してメソッドを呼び出すには、定義するときと同じように、コンマ(,)を用います。 -->

<-- /* 12月17日 今日はrubyのメソッドの戻り値について学習した。 
戻り値とは呼び出し元で受け取る処理結果のことをいい、このことを「メソッドが戻り値を返す」と言います。
メソッドの中でreturnを使うと、呼び出し元で値を受け取れるようになります。-->

<-- /* 12月18日 今日もrubyのメソッドの戻り値について学習した。
戻り値も引数と同様に、様々な値を用いることができます。
また、if文で使うような条件式をreturnすると、その条件式の結果として得られる真偽値（trueまたはfalse）を返すことができます。  -->

<-- /* 12月19日 今日もrubyのメソッドの戻り値のreturnについて学習した。
returnは、戻り値を返すだけでなく、メソッドの処理を終了させる性質も持っています。 -->

<-- /* 12月20日 今日はrubyのキーワード引数について学習した。
① 定義側で、引数の後にコロンを付ける
② 呼び出し側で、値の前に引数名を書く
とすることで、キーワード引数を持つメソッドを書くことができます。 -->

<-- /* 12月21日 今日はrubyのクラスの定義について学習した。
クラスは「class クラス名」とすることで定義できます。
クラス名は必ず大文字で始めることと、「end」を書く必要があること -->

<-- /* 12月22日 今日はrubyのインスタンス変数について学習した。
クラスのデータを定義する方法の1つに「attr_accessor シンボル」を使う方法があります。
ex  Menuクラスのインスタンスにnameという情報を持たせることができます。このnameという情報のことをインスタンス変数と呼びます。-->

<-- /* 12月23日 今日はrubyのインスタンスの生成について学習した。
クラス（設計図）を元に、新しくインスタンスを生成するには、「クラス名.new」とします。
「変数名 = クラス名.new」とすることで、生成したインスタンスを変数に代入することができます。-->

<-- /* 12月24日 今日はrubyのインスタンスの変数について学習した。
インスタンスに情報をもたせるには、クラスで用意したインスタンス変数に値を代入する必要があり、
具体的には「インスタンス.変数名 = 値」とすることで、そのインスタンス変数に値をセットすることができます。 -->

<-- /* 12月25日 今日はrubyのインスタンスメソッドについて学習した。
クラスの中にメソッドを定義することができます。定義したメソッドは、インスタンスに対して使うようにして呼び出します。
具体的には、「インスタンス.メソッド名」のようにすることで、そのメソッドを呼び出すことができます。 -->

<-- /* 12月26日 今日もrubyのインスタンスメソッドについて学習した。
クラスの中で定義し、インスタンスに対して呼び出すメソッドのことをインスタンスメソッドと呼びます。 -->

<-- /* 12月27日 今日はrubyのメソッドとインスタンス変数について学習した。
インスタンスメソッドの中では、特殊な変数「self」を用いて「self.変数名」とすることで、インスタンス変数を扱うことができるようになります。
インスタンスメソッドでは、変数「self」に、呼び出したインスタンス自身が代入されています。 -->

<-- /* 12月28日 今日はrubyのクラスとインスタンスの復習をした。
クラスは設計図のようなもので、その設計図からつくる実際の「もの」にあたるものがインスタンスという。
インスタンスが持つ情報である「インスタンス変数」と、インスタンスに対して呼び出す「インスタンスメソッド」は、クラスの中で定義します。 -->

<-- /* 12月29日 今日はrubyのinitializeメソッドについて学習した。
initializeメソッドはインスタンスを生成した直後に処理を実行することができる。
initializeメソッドは、「クラス名.new」でインスタンスを生成した直後に自動で呼び出されます。 -->

<-- /* 12月30日 今日もrubyのinitializeメソッドの引数について学習した。
nitializeメソッドは通常のインスタンスメソッドと同じように、引数を渡すこともでき、
「クラス.new」に対して引数を渡すことで、initializeメソッドにその値を渡すことができます。 -->

<-- /* 12月31日 今日はrubyのインスタンスの配列について学習した。
Menuクラスから生成したインスタンスも、配列の要素にすることが可能です。
各インスタンスを要素とする配列を変数menusに代入しその配列に対してeach文を用いることできます。 -->


<-- /* 1月1日 今日はrubyの注文システムの入力について学習した。
「変数 = gets.chomp」とすることで、エンターキーを押されるまでに入力された値を変数に代入することができます。 -->

<-- /* 1月2日 今日はrubyの継承について学習した。
継承とはあるクラスを元にして新たなクラスをつくることをいいます。
「class 新しいクラス名 < 元となるクラス名」とすることで他のクラスを継承して、新しいクラスを定義することができます。 -->

<-- /* 1月3日 今日もrubyの継承について学習した。
継承をすると、子クラスは親クラスのインスタンス変数とインスタンスメソッドを引き継ぎます。 -->

<-- /* 1月4日 今日もrubyの継承について学習した。
子クラスにインスタンス変数を追加するためには、これまで通り「attr_accessor」を用います。 -->

<-- /* 1月5日 今日はrubyのオーバーライドについて学習した。
親クラスにあるメソッドと同じ名前のメソッドを子クラスで定義すると、メソッドを上書きすることができます。これをメソッドの「オーバーライド」と呼びます。 -->

<-- /* 1月6日 今日もrubyのオーバーライドについて学習した。
オーバーライドしたメソッドの中で「super」とすることで、親クラスの同名のメソッドを呼び出すことができます。
あくまでメソッドを呼び出しているので、親クラスのメソッドの定義に合わせて、superに対して引数を渡す必要があります。 -->

<-- /* 1月7日 今日はrubyのdateクラスについて学習した。
日付を扱うためには、Dateクラスというものを用います。
DateクラスとはRubyがすでに用意しているクラスで、requireを用いて読み込むことで、自分でクラスを定義しなくても使うことができます。 -->

<-- /* 1月8日 今日もrubyのdateクラスについて学習した。
DateクラスのインスタンスをつくるためにDate.newを使いましたが、Dateクラスでは、Date.todayとすることで、
今日の日付のインスタンスをつくることができるようになります。 -->

<-- /* 1月9日 今日はrubyのクラスメソッドについて学習した。
クラスメソッドとはクラスに対して呼び出すメソッドのことをという。
（def クラス名.メソッド名）とすることで定義できます。インスタンスメソッドとの違いはメソッド名の前にクラス名を書く必要がある。 -->

<-- /* 1月10日 今日はrubyのクラスメソッドの処理について学習した。
 Dateクラスを用いて、今日の日付を取得するには
 ex
  def Menu.is_discount_day?
   todey = Date.todey
  end                        -->

  <-- /* 1月11日 今日はrubyのクラスメソッドについて学習した。
  クラスメソッドを呼び出すには、定義時と同じように、「クラス名.メソッド名」とすることで呼び出すことができます。 -->

  <-- /* 1月12日 今日はruby on railsついて学習した。
  ruby on railsとはWebアプリケーション開発のためのフレームワーク事をいう。
  Railsで開発を始めるには、「rails new アプリケーション名」というコマンドをターミナルで実行します。 -->

  <-- /* 1月13日 今日はruby on rails昨日の続きを学習した。
  トップページを作成するには、「rails generate controller home top」というコマンドをターミナルで実行します。 -->

  <-- /* 1月14日 今日はruby on railsのビューについてを学習した。
  ビューとは、ページの「見た目」を作るためのHTMLファイルこと。viewsフォルダの中に置かれます。
  ビュー（HTMLファイル）の中身がブラウザに表示される内容なので、そのファイルを編集することで、表示する内容を変更することができます。 -->

  <-- /* 1月15日 今日はruby on railsのコントローラと、HTMLの基礎についてを学習した。
  ページを表示するとき、Railsの中ではコントローラを経由してビューをブラウザに返しています。
  コントローラ内のアクションは、ブラウザに返すビューをviewsフォルダの中から見つけ出す役割を担っています。
  HTMLとはウェブサイトに表示される情報を記載する言語です。〇〇.htmlという名前のファイルに記述します -->

  <-- /* 1月16日 今日はruby on railsのルーティングについてを学習した。
  ルーティングとは、Rails内ではコントローラを経由してビューを返していますが、ブラウザとコントローラを繋ぐ役割を担うのがルーティングです。
  ページが表示されるまでに、ルーティング→コントローラ→ビューという順で処理していきます。 -->

  <-- /* 1月17日 今日はruby on railsのルーティングについてを学習した。
  ルーティングを書き換えることで、トップページのURLを変更することができます。 -->

  <-- /* 1月18日 今日はruby on railsのコマンドについてを学習した。
  トップページを作るときに入力したコマンドには、実は「コントローラ名」と「アクション名」が含まれています。
  すでに作られているルーティングとコントローラのファイルにコードを書き足すことで、ルーティングとアクションを追加できます。 -->

  <-- /* 1月19日 今日はruby on railsのcssについてを学習した。
  Railsでは、「stylesheets」フォルダの中に保存されているCSSファイルにコードを書けば、すべてのビューにCSSが適用されます。 -->

  <-- /* 1月20日 今日はruby on railsのcssの画像を表示についてを学習した。
 画像は、「public」フォルダに配置しておくと、「<img src="/画像名" >」や「background-image: url("/画像名");」
 のように、画像名を指定するだけで、画像を表示することができます。  -->

 <-- /* 1月21日 今日はruby on railsのデータベースについてを学習した。
 datebase.ymlとは、Railsアプリケーションのデータベースの設定ファイル。 
 ruby on railsはこれを編集することでデータベースの設定を運用環境ごとに変更できます。-->

 <-- /* 1月22日 今日はruby on railsのリンクの作り方についてを学習した。
 リンクを作成するためには、<a>タグでテキストを囲み、「href=" "」の中にURLを指定する必要があったことで
 hrefの中身をルーティングのURL部分と同じにすることで、簡単にリンク先を指定することができます。 -->

 <-- /* 1月23日 今日はruby on railsの投稿一覧ページを作成についてを学習した。
 一覧ページを作成する時は、indexというアクション名を使用することが一般的なので、indexアクションを用意します。
 「rails g controller」をターミナルに入力し、viewsファイルに投稿一覧ページ用のHTMLを書いていきます。 -->

 <-- /* 1月24日 今日はruby on railsの変数の使い方についてを学習した。
 viewファイル内でindex.html.erbのようなerbという形式のファイルでは<% %>で囲むことで、HTMLファイルの中にRubyのコードを記述することができます。 -->

 <-- /* 1月25日 今日はruby on railsの配列についてを学習した。
 変数postsを用意し、それぞれの投稿データが入っている配列を代入します。
 配列postsから要素を1つずつ取り出して変数postに代入し、表示しています。こうすることで、postsの要素の数だけeach文の中身が実行されるので、投稿の数だけHTMLを書く必要がなくなります。
 「<%= %>」ではなく「<% %>」で囲むことに注意する。 -->

 <-- /* 1月26日 今日はruby on railsのアクションで変数を定義についてを学習した。
 ビューで使う変数はアクション内で定義するするには、「def index」と「end」の間で変数を定義することで、その変数をindex.html.erb内で使用することができます。 -->

 <-- /* 1月27日 今日はruby on railsのデータベースの仕組みについてを学習した。
 データベースは「テーブル」と呼ぶ表でデータを管理しています。投稿データを扱うための「postsテーブル」で、横の行が１つ１つの投稿データになっています。
 縦の列のことを「カラム」、1行ずつのデータのことを「レコード」と呼びます。 -->

 <-- /* 1月28日 今日はruby on railsのテーブルの仕組みについてを学習した。
 マイグレーションファイルを使って、データベースに変更を反映するには、rails db:migrateを使います。 -->

 <-- /* 1月29日 今日はruby on railsのモデルについてを学習した。
 rails g modelコマンドによって、Postモデルが定義されたファイル、post.rbが、app/modelsフォルダの中に作成されています。 -->

 <-- /* 1月30日 今日はruby on railsのrails consoleの使い方についてを学習した。
 ターミナル上で「rails console」と入力し実行（Enter）することで、コンソールを起動することができます。 -->

 <-- /* 1月31日 今日はruby on railsのテーブルにデータを作成についてを学習した。
 インスタンスを作成するにはnewメソッドを使います。
 作成したPostインスタンスをpostsテーブルに保存するには、saveメソッドを使います。 -->

 
 <-- /* 2月1日 今日はruby on railsのテーブルからデータを取り出す方法についてを学習した。
 posts テーブルに保存されているデータを取得する方法として「Post.first」とすることで、 posts テーブルにある最初のデータを取得することができる。
 「post.content」とすることで「Post.first」で取得したデータから投稿内容を取得することができる。 -->

 <-- /* 2月2日 今日もruby on railsのテーブルからデータを取り出す方法についてを学習した。
 テーブルに保存されている全てのデータを取得するには、右の図のように「Post.all」を使うとテーブルにある全てのデータが配列で取得できる。 -->

 <-- /* 2月3日 今日もruby on railsのテーブルの全ての投稿データを表示についてを学習した。
 postsコントローラのindexアクション内の@postsに、Post.allで取得したデータを代入します。
 ビューでは@postsに代入されている配列データをeach文で1つずつ変数postに代入し、投稿内容を繰り返し表示させます。 -->

 <-- /* 2月4日 今日もruby on railsの自動生成されるカラムについてを学習した。
 idカラムには、データベースに保存される時に数字が自動で入り、1から順に入っていき、データ毎に重複しないようになっている。 -->

 <-- /* 2月5日 今日もruby on railsのfind_byメソッドについてを学習した。
 ある条件に合致するデータを取得することができ、「モデル名.find_by(カラム名: 値)」とすることで、その値を持ったデータをデータベースから取得することができます。 -->

 <-- /* 2月6日 今日もruby on railsのparamsついてを学習した。
 コントローラのアクション内では、ルーティングで設定したURLの「:id」の値を取得することができ、その値はparamsという。 -->

 <-- /* 2月7日 今日もruby on railsもparamsついてを学習した。
 showアクションで変数@postを定義し、idカラムの値がparams[:id]と等しい投稿をデータベースから取得して代入します。
 @postをshow.html.erbで表示することで、各URLに対応した投稿のデータが表示される。 -->

 <-- /* 2月8日 今日もruby on railsも詳細ページへのリンクを作成ついてを学習した。
 投稿一覧ページに、各投稿の詳細ページへのリンクを作成には各投稿の内容の部分をクリックすると詳細ページに移動できるように、link_to(post.content, "/posts/#{post.id}")とします。
  -->

 <-- /* 2月9日 今日もruby on railsは新規投稿ページを作成ついてを学習した。
 新規投稿ページは、「localhost:3000/posts/new」というURLでアクセスできるようにするためにルーティング、アクション、ビューを追加します。
 アクションは、newアクションとします。 -->

 <-- /* 2月10日 今日もruby on railsは入力フォームを作成ついてを学習した。
 HTML & CSSと同じように<textarea>タグや<input>タグを用いることで入力フォームを作成することができます。
 送信ボタンにはtype="submit"と、value="投稿"を指定することに気をつける。 -->

 <-- /* 2月11日 今日もruby on railsは入力フォームの保存ついてを学習した。
 form_tagメソッドを用いると、フォームに入力されたデータを送信することができます。form_tagは、「form_tag(送信先のURL) do」のように送信先のURLを指定します。
 <input type="submit" ...>のボタンを押した時に、指定されたURLにデータが送信されます。 -->

 <-- /* 2月12日 今日はruby on railsはリダイレクトについてを学習した。
 他のURLに転送（リダイレクトという）するには、redirect_toメソッドを用います。
 redirect_toは「redirect_to(URL)」とすることで、そのページに転送することができます。 -->

<-- /* 2月13日 今日はruby on railsはname属性ついてを学習した。
<textarea>タグにname属性を指定すると、入力データを送信することができるようになり、name属性の値をキーとしたハッシュがRails側に送られます。
name属性を指定したフォームに入力されたデータは、コントローラのアクション内で受け取ります。
フォームのデータは、変数paramsで受け取ります。paramsはname属性に設定した文字列をキーとしたハッシュになっています。 -->

<-- /* 2月14日 今日はruby on railsはorderメソッドについてを学習した。
orderメソッドを用いることで、投稿一覧を並び替えることができます。
order(カラム名: 並び替えの順序）のように使います。並び替えの順序には、昇順（:asc）と降順（:desc）のどちらかを指定でき、
created_atを基準に降順（:desc）に並べ替えると、新しいものから順番に表示するようにできます。 -->

<-- /* 2月15日 今日はruby on railsはレイアウトの仕組みについてを学習した。
「views/layouts/application.html.erb」には<%= yield %>というコードがあります。top.html.erbなどの各ビューファイルは、この<%= yield %>の部分に代入され、
application.html.erbの一部としてブラウザに表示され、この仕組みによって、ヘッダーなどの共通のレイアウトを1つにまとめることができます。 -->

<-- /* 2月16日 今日はruby on railsはlink_toメソッドについてを学習した。
link_toというメソッドを使うと<a>タグを作成することができる。link_to メソッドは Ruby のコードなので、「<%=%>」で囲むことに注意する。 -->

<-- /* 2月17日 今日はruby on railsは投稿を編集についてを学習した。
投稿を編集するには、①編集したい投稿を取得し、②その投稿のcontentの値を上書きした後に、③データベースに保存し,
post.content = "新しい値"とすることで、投稿のcontentの値を上書きすることができます。 -->

<-- /* 2月18日 今日はruby on railsは投稿を削除についてを学習した。
削除したい投稿を取得し、その投稿に対してdestroyメソッドを用いることで、データベースから削除することができます。 -->

<-- /* 2月19日 今日はruby on railsは投稿編集ページを作成についてを学習した。
投稿編集ページを判別するために、投稿編集ページのURLには編集したい投稿のidを入れるようにします。そのため、showアクションと同様にルーティングにidを含むようにします。
postsコントローラ内にeditアクションを作成し、対応するビューとして、edit.html.erbも作成します。 -->

<-- /* 2月20日 今日はruby on railsはフォームに初期値についてを学習した。
フォームの初期値として、編集したい投稿内容を表示し、editアクションで、URLのidと同じidの投稿データをデータベースから取得し、そのcontentの値（＝投稿の内容）を初期値に設定します。
 -->

<-- /* 2月21日 今日はruby on railsはupdateアクションについてを学習した。
updateアクションはフォームの値を受け取るので、ルーティングをgetではなく、postにする必要があり、特定のidの投稿を更新するので、URLにidを含むようにします。
また、フォームで入力した内容をデータベースに保存するためには、フォームのデータをupdateアクションに送信する必要があり、新規投稿ページを作ったときと同様に、form_tagメソッドを用いて、送信先を指定します。 -->

<-- /* 2月22日 今日はruby on railsはparamsについてを学習した。
ユーザーがフォームを送信したとき、そのフォームで入力された値やURLのクエリ文字列で渡された値などが params メソッドでハッシュオブジェクトとして取得できます。
 -->

<-- /* 2月23日 今日はruby on railsはdestroyアクションのルーティングについてを学習した。 
destroyアクションのルーティングはroutes.rbをgetではなくpostにします。
destroyアクションでも、URLのidから削除したい投稿を特定できるように、「posts/:id/destroy」とURLの中にidを含むことに注意します。 -->

<-- /* 2月24日 今日はruby on railsはdestroyアクションへのリンクについてを学習した。
link_to を用いて destroy アクションへのリンクを作る場合は、link_toの第三引数に <%=link_to("削除", "/posts/#{@post.id}/destroy",{method: "post"})%>
とすることで、「post」として定義されているルーティングにマッチするようになります。 -->

<-- /* 2月25日 今日はruby on railsはバリデーションについてを学習した。
バリデーションとは不正なデータがデータベースに保存されないように、データをチェックする仕組みのことを言います。
・空のデータが登録できないようにする。
・すでに登録されている文字列を登録できないようにする。
・文字数制限をかける（パスワード） -->

<-- /* 2月26日 今日はruby on railsはバリデーションの文字数の制限についてを学習した。
「length」を用い、{maximum: 数値}を指定することで、最大文字数を設定することができます。
バリデーションで検証する内容は、実はハッシュとなっており、コンマ( , )で区切ることで、複数指定することができます。 -->

<-- /* 2月27日 今日はruby on railsはバリデーションの表示するページを切り替える方法についてを学習した。
投稿を保存できなかった場合は投稿一覧ページの代わりに投稿編集ページに転送するようにし、saveメソッドが、保存できたかどうかで「true」または「false」を返すことを用います。
saveメソッドの戻り値をif文の条件式は
if @post.save
else
end  とする事で表示ページを切り替えることができる。 -->

<-- /* 2月28日 今日もruby on railsのバリデーションの表示するページを切り替える方法についてを学習した。
・updateアクションでは、投稿失敗時にeditアクションに転送している
・editアクションでは、データベースから編集前のデータを取得している
・フォームの初期値は、②で取得した@post.contentの内容である
と投稿失敗時には直前の内容ではなく編集前のデータが表示されてしまい、投稿失敗時に直前の投稿内容が消えてしまう。 -->

<-- /* 2月29日 今日はruby on railsもバリデーションの表示するページを切り替えるのエラーメッセージを表示についてを学習した。
saveメソッドを呼び出した際にバリデーションに失敗すると、Railsでは自動的にエラーメッセージが生成されるようになっています。
@post.errors.full_messagesの中に、エラー内容が配列で入ります。 -->


<-- /* 3月1日 今日はruby on railsのフラッシュについてを学習した。 
ページ上に1度だけ表示されるメッセージをフラッシュといいます。
フラッシュが表示された後、ページを更新したり、別のページに移動したりすると、フラッシュは表示されなくなります。
フラッシュを表示するために、特殊な変数flashが用意されています。アクションで変数flash[:notice]に文字列を代入すると、flash[:notice]をビューで使うことができます。 -->

<-- /* 3月2日 今日はruby on railsのモデルとテーブルについてを学習した。
Userモデルとusersテーブルをつくるためは『rails g model モデル名 カラム名:データ名 』を実行します。
データベースに変更を反映させるには『rails db:migrate』を実行します。 -->

<-- /* 3月3日 今日はruby on railsのユーザーのデータを作りについてを学習した。
テーブルにデータを保存するには以下の手順は
① new メソッドで User モデルのインスタンスを作成 
② save メソッドで users テーブルに保存 -->

<-- /* 3月4日 今日はruby on railsのバリデーションについてを学習した。
今のままだとnameとemail が空でもユーザーを作成できてしまうため、
データベースにすでに保存されているemailで新たにユーザーを登録できないように、「emailの重複がないか」をチェックするためのバリデーションを追加します。
uniqueness: true を指定することでチェックすることができます。 -->

<-- /* 3月5日 今日はruby on railsのユーザー機能についてを学習した。
ユーザー機能を追加していくにあたって①ユーザーの一覧②ユーザーの詳細③ユーザーの新規登録④ユーザーの情報編集の4つの機能を追加する。
まずは①ユーザーの一覧はrails g controllerコマンドを用いて、userコントローラを作成し一覧ページのアクション名indexを作っていきます。
indexアクション内でデータベースからユーザーデータを@users = User.allとすることで、取得した全件データを@user変数に設定することができます。
-->

<-- /* 3月6日 今日はruby on railsのユーザー機能の詳細ページについてを学習した。
URLにアクセスしたときに、Usersコントローラーのshowアクションを呼び出すルーティングを作成します。
showアクションを作成しshow.html.erbを作成、ユーザー一覧に表示されているユーザー名の部分を、ユーザー詳細ページへのリンクするようにします。 -->

<-- /* 3月7日 今日はruby on railsのユーザー登録機能についてを学習した。
Usersコントローラーのnewアクションを呼び出すルーティングを作成し、new.html.erbを作成してヘッダーにユーザー登録ページへのリンクを追加できるようにします。 -->

<-- /* 3月8日 今日はruby on railsのユーザーの保存についてを学習した。
Usersコントローラーのcreateアクションを呼び出すルーティングを作成し、ユーザー登録ページで「新規登録」ボタンが押されたときに、フォームのデータが/users/createに送信されるようにします。
-->

<-- /* 3月9日 今日はPythonの基本についてを学習した。
Pythonでは「print」を用いると文字を出力（表示）することができます。
文字列はシングルクォーテーション「''」またはダブルクォーテーション「""」で囲む必要があります。 -->

<-- /* 3月10日 今日はPythonのリストについてを学習した。
リストの要素には、前から順に「0, 1, 2,・・・」と数字が割り振られています。これをインデックス番号といいます。インデックス番号は0から始まる点に注意します。
 -->

<-- /* 3月11日 今日もPythonのリストについてを学習した。
リスト[インデックス番号] = 値とすることで、リストの指定したインデックス番号の要素を更新することができます。
リスト.append(値)とすることで、すでに定義されているリストの末尾に新たな要素を追加することができます。 -->

<-- /* 3月12日 今日はPythonのfor文についてを学習した。
for文はリストの要素を順に取り出して処理を行うことができます。
「for 変数名 in リスト:」と書くことで、リストの要素の数だけ、処理を繰り返すことができます。
「for 変数名 in リスト:」とすると変数には、リストの要素が先頭から順に1つずつ入っていき、その上でfor文の中の処理が実行されます。処理はリストの要素の数だけ繰り返し行われます（繰り返し処理）。 -->

<-- /* 3月13日 今日はPythonの辞書についてを学習した。
辞書とはリストと同じように複数のデータをまとめて管理するのに用いられます。
リストとの違いは、個々の要素をインデックス番号ではなくキーと呼ばれる名前を付けて管理する点です。
辞書は{キー1: 値1, キー2: 値2, …}のように作ります。
ほとんどの場合、キーには文字列が使われます。
リストは要素を[]で囲みましたが、辞書は{}で囲みます。キーと値の間はコロン（:）、要素同士の間はコンマ（,）で区切ります。 -->

<-- /* 3月14日 今日もPythonの辞書についてを学習した。
辞書はリストと同じように要素の更新と追加をすることができます。
辞書名[キー名] = 値と書くことで要素の更新をすることができます。
辞書にすでにあるキー名を指定すると、値の追加ではなく更新になってしまうので注意。 -->

<-- /* 3月15日 今日はPythonのfor文についてを学習した。
リストと同じように、辞書もfor文を用いて要素を1つずつ取り出し、処理を行うことができます。
for 変数名 in 辞書:と書くことで繰り返し処理をすることができます。 -->

<-- /* 3月17日 今日はPythonのwhile文についてを学習した。
while文を用いると、「ある条件に当てはまる間、処理を繰り返す」といったことが可能になります。
while文は「while 条件式:」のように書きます。条件式の結果がTrueの間、while文内の処理を繰り返します。 -->

<-- /* 3月18日 今日はPythonのbreakについてを学習した。
breakを用いると繰り返し処理を終了することができます。if文などの条件分岐と組み合わせて使います。 -->

<-- /* 3月19日 今日はPythonのcontinueについてを学習した。
continueはbreakと違い、繰り返し処理を終了するとその周の処理だけをスキップすることができます。 -->

<-- /* 3月20日 今日はPythonの数値についてを学習した。
数値とは文字列と違って、クォーテーションで囲む必要がありません。「3 + 5」は計算結果である「8」を出力してくれます。
一方、「'3 + 5'」のようにクォーテーションで囲むと、文字列として解釈されて、そのまま「3 + 5」が出力されます。
このようにプログラミングの世界では、文字列と数値は全く異なるものとして扱われます。 -->

<-- /* 3月21日 今日はPythonの計算についてを学習した。
「3 + 5」は計算結果である「8」を出力してくれます。
一方、「'3 + 5'」のようにクォーテーションで囲むと、文字列として解釈されて、そのまま「3 + 5」が出力されます。
このようにプログラミングの世界では、文字列と数値は全く異なるものとして扱われます。
掛け算は「*」、割り算は「/」で表します。また、「%」で割り算の余りを計算することができます。 -->

<-- /* 3月22日 今日はPythonの変数についてを学習した。 
変数とは、データ（値）を入れておく箱のようなものでこの箱（変数）に名前（変数名）をつけることで、その名前を用いて変数に値を入れることや、変数から値を取り出すことができます。
変数は「変数名 = 値」で定義します。変数名はクォーテーションで囲む必要はありません。
また、プログラミングの「=」は「等しい」という意味ではなく、「右辺を左辺に代入する」という意味になる。 -->

<-- /* 3月23日 今日もPythonの変数についてを学習した。
変数は変数名の頭文字を数字にすることはできません。また、「user_name」のように2語以上の変数名を使うときは、
単語と単語の間を _ (アンダーバー)で区切ります。
変数を使うことには、他にも以下のようなメリットがあります。
・同じデータを繰り返し利用することができる
・変数の値に変更が必要になった場合、変更する箇所が1箇所で済む -->

<-- /* 3月24日 今日はPythonのインスタンスの生成についてを学習した。
「クラス名()」とそのクラスを呼び出すことで、クラス（設計図）を用いて新しくインスタンスを生成することができます。
また、「変数名 = クラス名()」とすることで、生成したインスタンスを変数に代入することができます。 -->

<-- /* 3月25日 今日はPythonのインスタンス変数についてを学習した。
「menu_item1.name = '○○'」とすることで、menu_item1に「name」が「○○」であるという情報を追加することができます。
この時、「name」のことを「インスタンス変数」と呼びますので覚えておきましょう。
「インスタンス.インスタンス変数名」とすることで、そのインスタンス変数の値を用いることができます。 -->

<-- /* 3月26日 今日はPythonのif文についてを学習した。
if文を用いると「もし○○ならば☓☓を行う」という条件分岐が可能になります。
条件式の中では、２つの値を比較するための記号「比較演算子」がよく使われます。 -->

<-- /* 3月27日 今日はPythonの真偽値についてを学習した。
真偽値とは扱うデータ型、「真偽値型」には「True」と「False」という2つの値が存在します。比較演算子を用いた条件式の部分が、成り立つときは「True」、成り立たないときは「False」となります。
「True」と「False」のそれぞれの頭文字は大文字なので注意します。
比較演算子には、==と!=といった値の等しさを比較する記号以外に、値の大小を比較する記号が存在します。
数学でも用いられる<, >という大小比較の記号です。「x > y」はxがyより大きければTrue, 小さければFalseを返します。「x < y」はその逆になります。 -->

<-- /* 3月28日 今日はPythonのelseについてを学習した。
if文に「else」を組み合わせることで「もし○○ならば☓☓を行う、そうでなければ△△を行う」という条件分岐ができるようになります。
if文の条件がFalseのとき、elseの処理が実行されます。 -->